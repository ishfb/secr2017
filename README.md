# Доклад

## Цель
Продать четыре шага, которыми я пользуюсь при работе с кодом:
* Создать интерфейс
* Внедрить интерфейс
* Разработать тесты
* Реализовать интерфейс

"Продать" значит:
* объяснить, что этот подход
  * экономит время
  * защищает от багов
* продемонстрировать его на примере

## Чем хороши шаги
1. Создать интерфейс, не реализуя его
2. Внедрить интерфейс в существующий код
   * внедрение интерфейса сразу после его разработки позволяет понять, насколько хорошо он подходит для данной задачи, и сразу его исправить, если это не так
   * за счёт того, что мы ещё не реализовывали интерфейс, мы экономим время
   * в конце этого шага мы получаем интерфейс, который лучше всего подходит для нашей конкретной задачи
3. Разработать тесты на созданный интерфейс
   * мы продумываем все крайние случаи заранее, это позволит нам сразу учесть их во время реализации
   * запустив тесты на нереализованном интерфейсе, мы можем убедиться, что корректно встроили их в систему тестирования (потому что все они должны упасть)
     * это важно, когда у нас уже 100500 тестов и мы запускаем их все
4. Реализовать интерфейс так, чтобы он прошёл все тесты
   * отложив реализацию напоследок, мы гарантируем, что будем реализовывать тот интерфейс, который наилучшим образом подходит для нашей задачи
   * когда мы его реализуем, у нас уже будет способ сразу проверить корректность нашей реализация, а значит большинство допущенных багов мы сразу же поймаем, потому что чем меньше время между допущением ошибки и её обнаружением, тем проще её исправить

## План

### Введение
* Каковы наиболее частые причины изменения кода?
  * Добавление новой функциональности
  * Рефакторинг
  * Исправление багов
* Первые два пункта занимают бОльшую часть времени
* За пять лет работы над различными проектами в Яндексе я выработал для себя последовательность шагов, которую я применяю, добавляя новую функциональность или выполняя рефакторинг
* Перечисляем шаги
* Эта последовательность шагов позволяет ощутимо ускорить процесс разработки и защититься от большого количества багов

### Пример
* Рассмотрим применение этих шагов на примере рефакторинга.
* Пример реальный. Я действительно решал аналогичную задачу в своей практике.
* Описываем сервер комментариев, показывая таблицу, как он должен работать.
* Показываем код и проговариваем, как он устроен
* В коде немало проблем, давайте решим одну из них: ответы хардкодятся каждый раз при выводе в поток - высокая вероятность ошибиться.
* Напишем класс `HttpResponse`, который будет инкапсулировать в себе строковое представление HTTP-ответов и предоставлять удобный интерфейс для их создания
* Поехали:
  1. Первый шаг - создали интерфейс
  2. Второй шаг - внедряем интерфейс в наш код. Почему:
     * внедрение интерфейса сразу после его разработки позволяет понять, насколько хорошо он подходит для данной задачи, и сразу его исправить, если это не так
     * *на этом шаге мы просто определяем форму, не наполняя её содержанием*
     * за счёт того, что мы ещё не реализовывали интерфейс, мы экономим время
     * в конце этого шага мы получаем интерфейс, который лучше всего подходит для нашей конкретной задачи
  3. После внедрения анализируем, что получилось:
     * мы избавились от захардкоженных строк
     * код фомирования ответа громоздкий
     * у нас остались магические числа - 200 и 404
  4. Возращаемся на шаг 1 и меняем интерфейс
     * здесь проявляется экономия времени
     * мы продолжаем играть с формой, затачивая её под нашу задачу
  5. Внедряем изменившийся интерфейс, и он нас устраивает
  6. Не торопимся его реализовывать, вместо этого пишем тесты, потому что
     * мы продумываем все крайние случаи заранее, это позволит нам сразу учесть их во время реализации
     * запустив тесты на нереализованном интерфейсе, мы можем убедиться, что корректно встроили их в систему тестирования (потому что все они должны упасть)
        * это важно, когда у нас уже 100500 тестов и мы запускаем их все
  7. Запускаем тесты и видим, что они упали.
  8. Реализуем наш интерфейс и добиваемся успешного прогона всех тестов
     * отложив реализацию напоследок, мы гарантируем, что будем реализовывать тот интерфейс, который наилучшим образом подходит для нашей задачи
     * когда мы его реализуем, у нас уже будет способ сразу проверить корректность нашей реализации, а значит большинство допущенных багов мы сразу же поймаем, потому что чем меньше время между допущением ошибки и её обнаружением, тем проще её исправить

### Итоги
* В результате мы получаем корректный код, корректно встроенный в существующую систему. При этом по ходу продвижения к этой цели мы минимизировали риски возникновения багов или необходимости переделывать свою работу. А значит, мы сэкономили уйму времени на отладке и поиске багов во время эксплуатации системы.

# Заявка

## Краткое описание:
В докладе я расскажу о последовательности шагов, которую я использую каждый раз, когда мне надо внести изменения в существующий код. Последовательность такая:
1) разработать интерфейс
2) внедрить его в существующий код
3) покрыть этот интерфейс тестами
4) реализовать созданный интерфейс

Подробно на примерах будет рассказано, почему последовательность именно такая и как она снижает количество допускаемых багов и обеспечивает довольно высокую скорость разработки.

Целевая аудитория - разработчики с опытом участия в долгосрочных проектах, разрабатываемых командой из нескольких человек

## Расширенная аннотация:
Мой доклад основан на пятилетнем опыте работы над различными проектами Яндекса. На мой взгляд, самая частая задача, которую решают разработчики, - это внесение изменений в существующий код большого проекта. Это может быть как реализация новой функциональности, так и рефакторинг или исправление багов. При этом всегда есть риск посадить новые баги. Может возникнуть и другая проблема - мы сначала реализовали новую функциональность, а потом стали встраивать её в систему. И тут вознкли нюансы, которые заставили нас переделать немалую часть работы. Из-за этого длительность разработки увеличивается, сроки срываются, все страдают.

В своей практике я выработал последовательность шагов, последовательное применение которых существенно снижает перечисленные риски. Последовательность такая:
- разработать интерфейс, не реализуя его
- внедрить его в существующий код
- покрыть этот интерфейс тестами
- реализовать созданный интерфейс так, чтобы он проходил все созданные тесты

Последовательно применяя эти шаги, мы в первую очередь гарантируем, что наше решение корректно встраивается в существующую систему. При этом мы экономим немало времени, так как не приступаем к реализации до завершения внедрения. Если на первом шаге мы придумали интерфейс, который не удалось внедрить на втором, мы возвращаемся на шаг №1 и модифицируем придуманный интерфейс. За счёт того, что мы не тратили время на его реализацию и тестирование, мы экономим немало времени.

Когда интерфейс внедрён, можно переходить к его реализации. Но сначала мы разрабатываем набор тестов. Это очень важно делать до реализации. Предварительная разработка тестов позволяет нам сразу продумать все варианты использования и крайние случаи входных данных для нашего интерфейса. А значит, мы сразу же сможем реализовать интерфейс с учётом их всех, что снижает количество багов в итоговом коде.

Когда тесты готовы, то перед переходом к реализации интерфейса их все необходимо запустить и убедиться, что все они падают. Это будет гарантировать нам, что мы успешно встроили все тесты в нашу систему тестирования и они надёжно тестируют реализацию нашего интерфейса. Когда тесты разрабатываются в последнюю очередь, часто бывает, что они сразу начинают проходить. Это создаёт ложное чувство уверенности в том, что тестируемый код работает правильно. Однако в моей практике было несколько случаев, когда такое происходило из-за того, что
- тесты были некорректно встроены в систему тестирования и попросту не запускались
- тесты были написаны на скорую руку для галочки и не ловили даже тривиальные баги

Наконец, когда тесты написаны и встроены, мы реализуем наш интерфейс. В результате мы получаем корректный код, корректно встроенный в существующую систему. При этом по ходу продвижения к этой цели мы минимизировали риски возникновения багов или необходимости переделывать свою работу. А значит, мы сэкономили уйму времени на отладке и поиске багов во время эксплуатации системы.

